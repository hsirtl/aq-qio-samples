#!/usr/bin/env python
# coding: utf-8

import json
from re import T
from azure.quantum.optimization import Term, Problem, ProblemType
from azure.quantum import Workspace
from azure.quantum.optimization import SimulatedAnnealing # Change this line to match the Azure Quantum Optimization solver type you wish to use


# Copy the settings for your workspace below
with open('appsettings.json') as f:
    config = json.load(f)
    workspace = Workspace (
        subscription_id = config.get("workspace").get("subscription_id"),
        resource_group = config.get("workspace").get("resource_group"),
        name = config.get("workspace").get("name"),
        location = config.get("workspace").get("location")
)


def exactlyOneOutOfN(ids, penalty):
    terms = []

    for id1 in ids:
        terms.append(Term(c = -penalty, indices = [id1]))
        for id2 in ids:
            if id2 > id1:
                terms.append(Term(c = 2*penalty, indices = [id1, id2]))

    return terms


def maxOneOutOfTwo(id1, id2, penalty):
    terms = []

    terms.append(Term(c = penalty, indices = [id1, id2]))

    return terms


# create a cost function based on a problem statement
def createCostFunction(problemData):
    terms = []
    p = 5

    numofcolors = problemData.get('data').get('numofcolors')
    graph = problemData.get('data').get('graph')

    # create terms for coloring constraint: "each node must receive exactly one color"
    for n in range(len(graph)):
        ids = []
        for color in range(numofcolors):
            ids.append(n*numofcolors+color)
        retTerms = exactlyOneOutOfN(ids, p)
        for term in retTerms:
            terms.append(term)

    # create terms for coloring constraint: "neighbor nodes must not receive the same color"
    for node in graph:
        node_id = node.get('id')
        for neighbor in node.get('neighbors'):
            neighbor_id = neighbor
            if neighbor_id > node_id:
                for color in range(numofcolors):
                    retTerms = maxOneOutOfTwo(node_id*numofcolors + color, neighbor_id*numofcolors + color, 2)
                    for term in retTerms:
                        terms.append(term)

    return terms


def extractSolution(problemData, result):
    config = result.get("configuration")
    graph = problemData.get('data').get('graph')
    numofcolors = problemData.get('data').get('numofcolors')

    coloring = []

    for node in graph:
        node_id = node.get('id')
        for color in range(numofcolors):
            if config.get(str(node_id * numofcolors + color)):
                coloring.append({ "node": node.get('node'), "color": color })
                print("node: {}, color: {}".format(node.get('node'), color))

    result = {}
    result["coloring"] = coloring

    return result


def validateSolution(problem, solution):
    return True


def printProblem(problem):
    print(problem)


def printSolution(solution):
    print(solution)


# read problem data
problemData = {}
with open('problem_de_states.json') as f:
    problemData = json.load(f).get("problem")

# create a cost function out of the problem data
terms = createCostFunction(problemData)

# submit the cost function to a solver
problem = Problem(name="problem", problem_type=ProblemType.pubo, terms=terms)
solver = SimulatedAnnealing(workspace, timeout=100, seed=22)
job = solver.submit(problem)
job.refresh()

# get the result
result = job.get_results()

# extract the solution generated by the solver
solution = extractSolution(problemData, result)

# validate the solution
#isValidSolution = validateSolution(problemData, solution)
#if isValidSolution:
#    print ("Solution is valid.")
#else:
#    print ("Solution is not valid.")

# print the solution
printSolution(solution)
