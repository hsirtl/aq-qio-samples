#!/usr/bin/env python
# coding: utf-8

import json
from re import T
from azure.quantum.optimization import Term, Problem, ProblemType
from azure.quantum import Workspace
from azure.quantum.optimization import SimulatedAnnealing # Change this line to match the Azure Quantum Optimization solver type you wish to use


# Copy the settings for your workspace below
with open('appsettings.json') as f:
    config = json.load(f)
    workspace = Workspace (
        subscription_id = config.get("workspace").get("subscription_id"),
        resource_group = config.get("workspace").get("resource_group"),
        name = config.get("workspace").get("name"),
        location = config.get("workspace").get("location")
)


def exactlyOneOutOfN(ids, penalty):
    terms = []

    for id1 in ids:
        terms.append(Term(c = -penalty, indices = [id1]))
        for id2 in ids:
            if id2 > id1:
                terms.append(Term(c = 2*penalty, indices = [id1, id2]))

    return terms


def maxOneOutOfTwo(id1, id2, penalty):
    terms = []

    terms.append(Term(c = penalty, indices = [id1, id2]))

    return terms


# create a cost function based on a problem statement
def createCostFunction(problemData, numofcolors):
    terms = []
    p = 5
    graph = []
    id = 0
    subject_ids = {}

    base_data = problemData

    for entry in base_data:
        subject_ids[entry.get("subject")] = id
        id += 1

    for entry in base_data:
        subject = entry.get("subject")
        edges = entry.get("edges")
        neighbors = []
        for neighbor in edges:
            neighbors.append(subject_ids.get(neighbor))
        graph.append({ "id": subject_ids.get(subject), "node": subject , "neighbors": neighbors })

    # create terms for coloring constraint: "each node must receive exactly one color"
    for n in range(len(graph)):
        ids = []
        for color in range(numofcolors):
            ids.append(n*numofcolors+color)
        retTerms = exactlyOneOutOfN(ids, p)
        for term in retTerms:
            terms.append(term)

    # create terms for coloring constraint: "neighbor nodes must not receive the same color"
    for node in graph:
        node_id = node.get('id')
        for neighbor in node.get('neighbors'):
            neighbor_id = neighbor
            if neighbor_id > node_id:
                for color in range(numofcolors):
                    retTerms = maxOneOutOfTwo(node_id*numofcolors + color, neighbor_id*numofcolors + color, 2)
                    for term in retTerms:
                        terms.append(term)

    return (graph, terms)


def extractSolution(graph, result):
    config = result.get("configuration")
    #graph = problemData.get('data').get('graph')
    numofcolors = len(config) // len(graph)

    coloring = []

    for node in graph:
        node_id = node.get('id')
        for color in range(numofcolors):
            if config.get(str(node_id * numofcolors + color)):
                coloring.append({ "node": node.get('node'), "color": color })

    result = {}
    result["coloring"] = coloring

    return result


def validateSolution(problem, solution):
    base_data = problem
    conflicts = False
    coloring = {}
    solutionColoring = solution.get("coloring")
    
    for entry in solutionColoring:
        coloring[entry.get("node")] = entry.get("color")

    for entry in base_data:
        subject = entry.get("subject")
        subjectColor = coloring.get(subject)
        edges = entry.get("edges")
        for neighbor in edges:
            if subjectColor == coloring.get(neighbor):
                #print(f"{subject} and {neighbor} with same color {subjectColor}")
                conflicts = True

    return not(conflicts)


def printProblem(problem):
    print(problem)


def printSolution(solution):
    coloring = solution.get("coloring")
    for node in coloring:
        print("node: {}, color: {}".format(node.get('node'), node.get('color')))


# read problem data
problemData = {}
with open('subject-conflicts.json') as f:
    problemData = json.load(f)

isValidSolution = False
numberOfColors = 2

while (not(isValidSolution)):
    print(f"Trying with {numberOfColors} colors...")
    # create a cost function out of the problem data
    (graph, terms) = createCostFunction(problemData, numberOfColors)

    # submit the cost function to a solver
    problem = Problem(name="problem", problem_type=ProblemType.pubo, terms=terms)
    solver = SimulatedAnnealing(workspace, timeout=100, seed=22)
    job = solver.submit(problem)
    job.refresh()

    # get the result
    result = job.get_results()
    print("")

    # extract the solution generated by the solver
    solution = extractSolution(graph, result)

    # validate the solution
    isValidSolution = validateSolution(problemData, solution)
    if isValidSolution:
        print ("Solution is valid.")
    else:
        print ("Solution is not valid.")
        numberOfColors = numberOfColors + 1

# print the solution
printSolution(solution)
